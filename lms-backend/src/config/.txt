const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('✓ MongoDB connected successfully');
  } catch (error) {
    console.error('✗ MongoDB connection failed:', error.message);
    process.exit(1);
  }
};

module.exports = connectDB;  const User = require('../models/User');
const Course = require('../models/Course');
const Enrollment = require('../models/Enrollment');
const Progress = require('../models/Progress');

// @desc    Get dashboard stats
// @route   GET /api/admin/dashboard
// @access  Private/Admin
exports.getDashboard = async ( req, res ) => {
  try {
    const totalUsers = await User.countDocuments();
    const totalStudents = await User.countDocuments({ role: 'student' });
    const totalCourses = await Course.countDocuments();
    const totalEnrollments = await Enrollment.countDocuments();

    // Calculate total revenue
    const enrollmentStats = await Enrollment.aggregate([
      { $match: { status: 'approved' } },
      { $group: { _id: null, totalRevenue: { $sum: '$amount' } } },
    ]);

    const totalRevenue = enrollmentStats[0]?.totalRevenue || 0;

    // Revenue per course
    const revenuePerCourse = await Enrollment.aggregate([
      { $match: { status: 'approved' } },
      {
        $group: {
          _id: '$course',
          courseRevenue: { $sum: '$amount' },
          enrollmentCount: { $sum: 1 },
        },
      },
      { $lookup: { from: 'courses', localField: '_id', foreignField: '_id', as: 'course' } },
      { $unwind: '$course' },
      { $project: { courseName: '$course.name', courseRevenue: 1, enrollmentCount: 1 } },
    ]);

    // Monthly revenue
    const monthlyRevenue = await Enrollment.aggregate([
      { $match: { status: 'approved' } },
      {
        $group: {
          _id: { $dateToString: { format: '%Y-%m', date: '$approvedAt' } },
          revenue: { $sum: '$amount' },
        },
      },
      { $sort: { _id: 1 } },
    ]);

    res.status(200).json({
      success: true,
      data: {
        totalUsers,
        totalStudents,
        totalAdmins: totalUsers - totalStudents,
        totalCourses,
        totalEnrollments,
        totalRevenue,
        revenuePerCourse,
        monthlyRevenue,
      },
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get all users
// @route   GET /api/admin/users
// @access  Private/Admin
exports.getAllUsers = async (req, res) => {
  try {
    const { role, isActive } = req.query;
    const filter = {};

    if (role) filter.role = role;
    if (isActive !== undefined) filter.isActive = isActive === 'true';

    const users = await User.find(filter).sort('-createdAt');

    res.status(200).json({
      success: true,
      count: users.length,
      data: users,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Activate/Deactivate user
// @route   PUT /api/admin/users/:userId/toggle-status
// @access  Private/Admin
exports.toggleUserStatus = async (req, res) => {
  try {
    const user = await User.findById(req.params.userId);

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found',
      });
    }

    user.isActive = !user.isActive;
    await user.save();

    res.status(200).json({
      success: true,
      message: `User ${user.isActive ? 'activated' : 'deactivated'} successfully`,
      data: user,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get user's enrollment history
// @route   GET /api/admin/users/:userId/enrollments
// @access  Private/Admin
exports.getUserEnrollments = async (req, res) => {
  try {
    const enrollments = await Enrollment.find({ student: req.params.userId })
      .populate('course')
      .populate('approvedBy', 'fullName email');

    res.status(200).json({
      success: true,
      count: enrollments.length,
      data: enrollments,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get course analytics
// @route   GET /api/admin/courses/:courseId/analytics
// @access  Private/Admin
exports.getCourseAnalytics = async (req, res) => {
  try {
    const course = await Course.findById(req.params.courseId);

    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    const totalEnrollments = await Enrollment.countDocuments({ course: req.params.courseId });
    const approvedEnrollments = await Enrollment.countDocuments({
      course: req.params.courseId,
      status: 'approved',
    });
    const pendingEnrollments = await Enrollment.countDocuments({
      course: req.params.courseId,
      status: 'pending',
    });
    const rejectedEnrollments = await Enrollment.countDocuments({
      course: req.params.courseId,
      status: 'rejected',
    });

    const studentsProgress = await Progress.find({ course: req.params.courseId })
      .populate('student', 'fullName email')
      .sort('-progressPercentage');

    res.status(200).json({
      success: true,
      data: {
        course,
        enrollmentStats: {
          total: totalEnrollments,
          approved: approvedEnrollments,
          pending: pendingEnrollments,
          rejected: rejectedEnrollments,
        },
        studentProgress: studentsProgress,
      },
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
}; const User = require('../models/User');
const jwt = require('jsonwebtoken');

// Generate JWT Token
const generateToken = (id) => {
  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRE || '7d',
  });
};

// @desc    Student Signup
// @route   POST /api/auth/signup
// @access  Public
exports.signup = async (req, res) => {
  try {
    const { fullName, email, phone, password, passwordConfirm } = req.body;

    // Validation
    if (!fullName || !email || !phone || !password) {
      return res.status(400).json({
        success: false,
        message: 'Please provide all required fields',
      });
    }

    if (password !== passwordConfirm) {
      return res.status(400).json({
        success: false,
        message: 'Passwords do not match',
      });
    }

    // Check if user exists
    const userExists = await User.findOne({ email });
    if (userExists) {
      return res.status(409).json({
        success: false,
        message: 'Email already in use',
      });
    }

    // Create user
    const user = await User.create({
      fullName,
      email,
      phone,
      password,
      role: 'student',
    });

    // Remove password from output
    user.password = undefined;

    const token = generateToken(user._id);

    res.status(201).json({
      success: true,
      token,
      user,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Student/Admin Login
// @route   POST /api/auth/login
// @access  Public
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Validation
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Please provide email and password',
      });
    }

    // Check for user
    const user = await User.findOne({ email }).select('+password');

    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials',
      });
    }

    // Check if account is active
    if (!user.isActive) {
      return res.status(403).json({
        success: false,
        message: 'Your account has been deactivated',
      });
    }

    // Check if password matches
    const isMatch = await user.matchPassword(password);

    if (!isMatch) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials',
      });
    }

    // Remove password from output
    user.password = undefined;

    const token = generateToken(user._id);

    res.status(200).json({
      success: true,
      token,
      user,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get current logged in user
// @route   GET /api/auth/me
// @access  Private
exports.getMe = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);

    res.status(200).json({
      success: true,
      data: user,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Update user profile
// @route   PUT /api/auth/update-profile
// @access  Private
exports.updateProfile = async (req, res) => {
  try {
    const { fullName, phone } = req.body;

    const user = await User.findByIdAndUpdate(
      req.user.id,
      { fullName, phone },
      { new: true, runValidators: true }
    );

    res.status(200).json({
      success: true,
      data: user,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Change password
// @route   PUT /api/auth/change-password
// @access  Private
exports.changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword, newPasswordConfirm } = req.body;

    if (!currentPassword || !newPassword || !newPasswordConfirm) {
      return res.status(400).json({
        success: false,
        message: 'Please provide all password fields',
      });
    }

    if (newPassword !== newPasswordConfirm) {
      return res.status(400).json({
        success: false,
        message: 'New passwords do not match',
      });
    }

    const user = await User.findById(req.user.id).select('+password');

    // Check current password
    const isMatch = await user.matchPassword(currentPassword);

    if (!isMatch) {
      return res.status(401).json({
        success: false,
        message: 'Current password is incorrect',
      });
    }

    user.password = newPassword;
    await user.save();

    res.status(200).json({
      success: true,
      message: 'Password changed successfully',
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};  const Content = require('../models/Content');
const Course = require('../models/Course');
const fs = require('fs');
const path = require('path');

// @desc    Get all content for a course
// @route   GET /api/content/course/:courseId
// @access  Private
exports.getContentByCourse = async (req, res) => {
  try {
    const content = await Content.find({ course: req.params.courseId }).sort('order');

    res.status(200).json({
      success: true,
      count: content.length,
      data: content,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get single content
// @route   GET /api/content/:id
// @access  Private
exports.getContentById = async (req, res) => {
  try {
    const content = await Content.findById(req.params.id).populate('course');

    if (!content) {
      return res.status(404).json({
        success: false,
        message: 'Content not found',
      });
    }

    res.status(200).json({
      success: true,
      data: content,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Create content (Admin)
// @route   POST /api/content
// @access  Private/Admin
exports.createContent = async (req, res) => {
  try {
    const { courseId, title, type, description, externalLink, duration, order } = req.body;

    if (!courseId || !title || !type) {
      return res.status(400).json({
        success: false,
        message: 'Please provide courseId, title, and type',
      });
    }

    // Check if course exists
    const course = await Course.findById(courseId);
    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    const contentData = {
      course: courseId,
      title,
      type,
      description: description || '',
      order: order || 0,
    };

    // Handle different content types
    if (type === 'link') {
      if (!externalLink) {
        return res.status(400).json({
          success: false,
          message: 'External link is required for link type',
        });
      }
      contentData.externalLink = externalLink;
    }

    if (duration) {
      contentData.duration = duration;
    }

    // Handle file uploads
    if (req.files) {
      if (req.files.videoFile) {
        contentData.filePath = req.files.videoFile[0].path;
      }
      if (req.files.pdfFile) {
        contentData.filePath = req.files.pdfFile[0].path;
      }
      if (req.files.slideImages) {
        contentData.slideImages = req.files.slideImages.map((file) => file.path);
      }
    }

    const content = await Content.create(contentData);

    res.status(201).json({
      success: true,
      data: content,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Update content (Admin)
// @route   PUT /api/content/:id
// @access  Private/Admin
exports.updateContent = async (req, res) => {
  try {
    let content = await Content.findById(req.params.id);

    if (!content) {
      return res.status(404).json({
        success: false,
        message: 'Content not found',
      });
    }

    const { title, description, externalLink, duration, order } = req.body;

    if (title) content.title = title;
    if (description) content.description = description;
    if (externalLink) content.externalLink = externalLink;
    if (duration) content.duration = duration;
    if (order !== undefined) content.order = order;

    // Handle file updates
    if (req.files) {
      if (req.files.videoFile) {
        // Delete old file if exists
        if (content.filePath && content.type === 'video') {
          const oldPath = path.join(__dirname, '../../', content.filePath);
          if (fs.existsSync(oldPath)) {
            fs.unlinkSync(oldPath);
          }
        }
        content.filePath = req.files.videoFile[0].path;
      }

      if (req.files.pdfFile) {
        if (content.filePath && content.type === 'pdf') {
          const oldPath = path.join(__dirname, '../../', content.filePath);
          if (fs.existsSync(oldPath)) {
            fs.unlinkSync(oldPath);
          }
        }
        content.filePath = req.files.pdfFile[0].path;
      }

      if (req.files.slideImages) {
        // Delete old images
        content.slideImages.forEach((imgPath) => {
          const oldPath = path.join(__dirname, '../../', imgPath);
          if (fs.existsSync(oldPath)) {
            fs.unlinkSync(oldPath);
          }
        });
        content.slideImages = req.files.slideImages.map((file) => file.path);
      }
    }

    await content.save();

    res.status(200).json({
      success: true,
      data: content,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Delete content (Admin)
// @route   DELETE /api/content/:id
// @access  Private/Admin
exports.deleteContent = async (req, res) => {
  try {
    const content = await Content.findByIdAndDelete(req.params.id);

    if (!content) {
      return res.status(404).json({
        success: false,
        message: 'Content not found',
      });
    }

    // Delete files
    if (content.filePath) {
      const filePath = path.join(__dirname, '../../', content.filePath);
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    }

    if (content.slideImages && content.slideImages.length > 0) {
      content.slideImages.forEach((imgPath) => {
        const fullPath = path.join(__dirname, '../../', imgPath);
        if (fs.existsSync(fullPath)) {
          fs.unlinkSync(fullPath);
        }
      });
    }

    res.status(200).json({
      success: true,
      message: 'Content deleted successfully',
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
}; const Course = require('../models/Course');
const Content = require('../models/Content');

// @desc    Get all courses
// @route   GET /api/courses
// @access  Public
exports.getAllCourses = async (req, res) => {
  try {
    const courses = await Course.find({ isActive: true })
      .populate('instructor', 'fullName email')
      .sort('-createdAt');

    res.status(200).json({
      success: true,
      count: courses.length,
      data: courses,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get single course with content
// @route   GET /api/courses/:id
// @access  Public
exports.getCourseById = async (req, res) => {
  try {
    const course = await Course.findById(req.params.id).populate('instructor', 'fullName email');

    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    const content = await Content.find({ course: req.params.id }).sort('order');

    res.status(200).json({
      success: true,
      data: {
        course,
        content,
      },
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Create course (Admin only)
// @route   POST /api/courses
// @access  Private/Admin
exports.createCourse = async (req, res) => {
  try {
    const { name, description, fee, qrImage, category } = req.body;

    if (!name || !description || !fee || !qrImage) {
      return res.status(400).json({
        success: false,
        message: 'Please provide all required fields',
      });
    }

    const course = await Course.create({
      name,
      description,
      fee,
      qrImage,
      category: category || 'General',
      instructor: req.user.id,
    });

    res.status(201).json({
      success: true,
      data: course,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Update course (Admin only)
// @route   PUT /api/courses/:id
// @access  Private/Admin
exports.updateCourse = async (req, res) => {
  try {
    let course = await Course.findById(req.params.id);

    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    course = await Course.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });

    res.status(200).json({
      success: true,
      data: course,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Delete course (Admin only)
// @route   DELETE /api/courses/:id
// @access  Private/Admin
exports.deleteCourse = async (req, res) => {
  try {
    const course = await Course.findByIdAndDelete(req.params.id);

    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    // Delete all content related to this course
    await Content.deleteMany({ course: req.params.id });

    res.status(200).json({
      success: true,
      message: 'Course deleted successfully',
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Toggle course active status (Admin only)
// @route   PATCH /api/courses/:id/toggle-status
// @access  Private/Admin
exports.toggleCourseStatus = async (req, res) => {
  try {
    const course = await Course.findById(req.params.id);

    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    course.isActive = !course.isActive;
    await course.save();

    res.status(200).json({
      success: true,
      message: `Course ${course.isActive ? 'activated' : 'deactivated'} successfully`,
      data: course,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};  const Course = require('../models/Course');
const Content = require('../models/Content');

// @desc    Get all courses
// @route   GET /api/courses
// @access  Public
exports.getAllCourses = async (req, res) => {
  try {
    const courses = await Course.find({ isActive: true })
      .populate('instructor', 'fullName email')
      .sort('-createdAt');

    res.status(200).json({
      success: true,
      count: courses.length,
      data: courses,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get single course with content
// @route   GET /api/courses/:id
// @access  Public
exports.getCourseById = async (req, res) => {
  try {
    const course = await Course.findById(req.params.id).populate('instructor', 'fullName email');

    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    const content = await Content.find({ course: req.params.id }).sort('order');

    res.status(200).json({
      success: true,
      data: {
        course,
        content,
      },
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Create course (Admin only)
// @route   POST /api/courses
// @access  Private/Admin
exports.createCourse = async (req, res) => {
  try {
    const { name, description, fee, qrImage, category } = req.body;

    if (!name || !description || !fee || !qrImage) {
      return res.status(400).json({
        success: false,
        message: 'Please provide all required fields',
      });
    }

    const course = await Course.create({
      name,
      description,
      fee,
      qrImage,
      category: category || 'General',
      instructor: req.user.id,
    });

    res.status(201).json({
      success: true,
      data: course,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Update course (Admin only)
// @route   PUT /api/courses/:id
// @access  Private/Admin
exports.updateCourse = async (req, res) => {
  try {
    let course = await Course.findById(req.params.id);

    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    course = await Course.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });

    res.status(200).json({
      success: true,
      data: course,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Delete course (Admin only)
// @route   DELETE /api/courses/:id
// @access  Private/Admin
exports.deleteCourse = async (req, res) => {
  try {
    const course = await Course.findByIdAndDelete(req.params.id);

    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    // Delete all content related to this course
    await Content.deleteMany({ course: req.params.id });

    res.status(200).json({
      success: true,
      message: 'Course deleted successfully',
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Toggle course active status (Admin only)
// @route   PATCH /api/courses/:id/toggle-status
// @access  Private/Admin
exports.toggleCourseStatus = async (req, res) => {
  try {
    const course = await Course.findById(req.params.id);

    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    course.isActive = !course.isActive;
    await course.save();

    res.status(200).json({
      success: true,
      message: `Course ${course.isActive ? 'activated' : 'deactivated'} successfully`,
      data: course,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};   const Enrollment = require('../models/Enrollment');
const Course = require('../models/Course');
const Progress = require('../models/Progress');

// @desc    Get user's enrollments
// @route   GET /api/enrollments/my-enrollments
// @access  Private
exports.getMyEnrollments = async (req, res) => {
  try {
    const enrollments = await Enrollment.find({ student: req.user.id })
      .populate('course')
      .sort('-enrolledAt');

    res.status(200).json({
      success: true,
      count: enrollments.length,
      data: enrollments,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Enroll in a course
// @route   POST /api/enrollments/:courseId
// @access  Private/Student
exports.enrollCourse = async (req, res) => {
  try {
    const { courseId } = req.params;

    const course = await Course.findById(courseId);
    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found',
      });
    }

    // Check if already enrolled
    const existingEnrollment = await Enrollment.findOne({
      student: req.user.id,
      course: courseId,
    });

    if (existingEnrollment) {
      return res.status(409).json({
        success: false,
        message: 'You are already enrolled in this course',
      });
    }

    const enrollment = await Enrollment.create({
      student: req.user.id,
      course: courseId,
      amount: course.fee,
      status: 'pending',
    });

    res.status(201).json({
      success: true,
      data: enrollment,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Mark as paid (Student shows QR)
// @route   PUT /api/enrollments/:enrollmentId/mark-paid
// @access  Private/Student
exports.markAsPaid = async (req, res) => {
  try {
    const enrollment = await Enrollment.findById(req.params.enrollmentId);

    if (!enrollment) {
      return res.status(404).json({
        success: false,
        message: 'Enrollment not found',
      });
    }

    if (enrollment.student.toString() !== req.user.id.toString()) {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to update this enrollment',
      });
    }

    if (enrollment.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'Enrollment status cannot be updated',
      });
    }

    enrollment.status = 'pending'; // Keep as pending, waiting for admin approval
    await enrollment.save();

    res.status(200).json({
      success: true,
      message: 'Payment recorded. Waiting for admin approval',
      data: enrollment,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get all enrollments (Admin)
// @route   GET /api/enrollments
// @access  Private/Admin
exports.getAllEnrollments = async (req, res) => {
  try {
    const { status } = req.query;
    const filter = {};

    if (status) {
      filter.status = status;
    }

    const enrollments = await Enrollment.find(filter)
      .populate('student', 'fullName email phone')
      .populate('course', 'name fee')
      .sort('-enrolledAt');

    res.status(200).json({
      success: true,
      count: enrollments.length,
      data: enrollments,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Approve enrollment (Admin)
// @route   PUT /api/enrollments/:enrollmentId/approve
// @access  Private/Admin
exports.approveEnrollment = async (req, res) => {
  try {
    const enrollment = await Enrollment.findById(req.params.enrollmentId);

    if (!enrollment) {
      return res.status(404).json({
        success: false,
        message: 'Enrollment not found',
      });
    }

    if (enrollment.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'Only pending enrollments can be approved',
      });
    }

    enrollment.status = 'approved';
    enrollment.approvedAt = Date.now();
    enrollment.approvedBy = req.user.id;
    await enrollment.save();

    // Update course stats
    const course = await Course.findById(enrollment.course);
    course.totalEnrollments += 1;
    course.totalRevenue += enrollment.amount;
    await course.save();

    // Create progress record
    await Progress.create({
      student: enrollment.student,
      course: enrollment.course,
    });

    res.status(200).json({
      success: true,
      message: 'Enrollment approved successfully',
      data: enrollment,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Reject enrollment (Admin)
// @route   PUT /api/enrollments/:enrollmentId/reject
// @access  Private/Admin
exports.rejectEnrollment = async (req, res) => {
  try {
    const enrollment = await Enrollment.findById(req.params.enrollmentId);

    if (!enrollment) {
      return res.status(404).json({
        success: false,
        message: 'Enrollment not found',
      });
    }

    if (enrollment.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'Only pending enrollments can be rejected',
      });
    }

    enrollment.status = 'rejected';
    await enrollment.save();

    res.status(200).json({
      success: true,
      message: 'Enrollment rejected successfully',
      data: enrollment,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};   const Progress = require('../models/Progress');
const Content = require('../models/Content');
const Enrollment = require('../models/Enrollment');

// @desc    Get user's course progress
// @route   GET /api/progress/:courseId
// @access  Private
exports.getCourseProgress = async (req, res) => {
  try {
    const progress = await Progress.findOne({
      student: req.user.id,
      course: req.params.courseId,
    })
      .populate('course')
      .populate('completedContents');

    if (!progress) {
      return res.status(404).json({
        success: false,
        message: 'Progress not found',
      });
    }

    res.status(200).json({
      success: true,
      data: progress,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Mark content as completed
// @route   PUT /api/progress/:courseId/complete/:contentId
// @access  Private
exports.completeContent = async (req, res) => {
  try {
    const { courseId, contentId } = req.params;

    // Check enrollment approval
    const enrollment = await Enrollment.findOne({
      student: req.user.id,
      course: courseId,
    });

    if (!enrollment || enrollment.status !== 'approved') {
      return res.status(403).json({
        success: false,
        message: 'You do not have access to this course',
      });
    }

    let progress = await Progress.findOne({
      student: req.user.id,
      course: courseId,
    });

    if (!progress) {
      return res.status(404).json({
        success: false,
        message: 'Progress record not found',
      });
    }

    // Check if content already completed
    if (progress.completedContents.includes(contentId)) {
      return res.status(400).json({
        success: false,
        message: 'Content already completed',
      });
    }

    progress.completedContents.push(contentId);

    // Calculate progress percentage
    const totalContent = await Content.countDocuments({ course: courseId });
    progress.progressPercentage = Math.round(
      (progress.completedContents.length / totalContent) * 100
    );

    progress.lastAccessedAt = Date.now();
    await progress.save();

    res.status(200).json({
      success: true,
      message: 'Content marked as completed',
      data: progress,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get all student progresses (Admin)
// @route   GET /api/progress
// @access  Private/Admin
exports.getAllProgress = async (req, res) => {
  try {
    const { studentId, courseId } = req.query;
    const filter = {};

    if (studentId) filter.student = studentId;
    if (courseId) filter.course = courseId;

    const progress = await Progress.find(filter)
      .populate('student', 'fullName email')
      .populate('course', 'name')
      .sort('-updatedAt');

    res.status(200).json({
      success: true,
      count: progress.length,
      data: progress,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Send certificate to student (Admin)
// @route   PUT /api/progress/:progressId/send-certificate
// @access  Private/Admin
exports.sendCertificate = async (req, res) => {
  try {
    const progress = await Progress.findById(req.params.progressId).populate('student');

    if (!progress) {
      return res.status(404).json({
        success: false,
        message: 'Progress record not found',
      });
    }

    // Mark certificate as sent (no actual email in this implementation)
    progress.certificateSent = true;
    progress.certificateSentAt = Date.now();
    await progress.save();

    // TODO: Implement actual email sending using nodemailer

    res.status(200).json({
      success: true,
      message: 'Certificate marked as sent',
      data: progress,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};  // Authorize only admin
exports.authorize = (...roles) => {
  return (req, res) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: `User role '${req.user.role}' is not authorized to access this route`,
      });
    }
    // next();
  };
}; const jwt = require('jsonwebtoken');
const User = require('../models/User');

// Protect routes - verify JWT token
exports.protect = async (req, res) => {
  let token;

  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return res.status(401).json({ success: false, message: 'Not authorized to access this route' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = await User.findById(decoded.id);

    if (!req.user) {
      return res.status(401).json({ success: false, message: 'User not found' });
    }

    if (!req.user.isActive) {
      return res.status(403).json({ success: false, message: 'User account is deactivated' });
    }

    // next();
  } catch (error) {
    return res.status(401).json({ success: false, message: 'Token is not valid' });
  }
};

// Get current logged in user
exports.getCurrentUser = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    res.status(200).json({ success: true, data: user });
    
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
};const mongoose = require('mongoose');

const contentSchema = new mongoose.Schema(
  {
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Course',
      required: true,
    },
    title: {
      type: String,
      required: [true, 'Please provide content title'],
      trim: true,
    },
    type: {
      type: String,
      enum: ['video', 'pdf', 'image', 'link'],
      required: true,
    },
    description: {
      type: String,
      default: '',
    },
    // For video, pdf, image
    filePath: {
      type: String,
      default: null,
    },
    // For Google Drive link
    externalLink: {
      type: String,
      default: null,
    },
    // For image slides (array)
    slideImages: [
      {
        type: String,
        default: null,
      },
    ],
    duration: {
      type: Number, // in minutes
      default: null,
    },
    order: {
      type: Number,
      default: 0,
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model('Content', contentSchema);const mongoose = require('mongoose');

const courseSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: [true, 'Please provide course name'],
      trim: true,
    },
    description: {
      type: String,
      required: [true, 'Please provide course description'],
    },
    fee: {
      type: Number,
      required: [true, 'Please provide course fee'],
      min: 0,
    },
    qrImage: {
      type: String,
      required: [true, 'Please provide QR image path'],
    },
    instructor: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    category: {
      type: String,
      default: 'General',
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    totalEnrollments: {
      type: Number,
      default: 0,
    },
    totalRevenue: {
      type: Number,
      default: 0,
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model('Course', courseSchema);const mongoose = require('mongoose');

const enrollmentSchema = new mongoose.Schema(
  {
    student: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Course',
      required: true,
    },
    status: {
      type: String,
      enum: ['pending', 'approved', 'rejected'],
      default: 'pending',
    },
    paymentMethod: {
      type: String,
      default: 'manual-qr',
    },
    paymentProof: {
      type: String,
      default: null,
    },
    amount: {
      type: Number,
      required: true,
    },
    enrolledAt: {
      type: Date,
      default: Date.now,
    },
    approvedAt: {
      type: Date,
      default: null,
    },
    approvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      default: null,
    },
  },
  { timestamps: true }
);

// Prevent duplicate enrollments
enrollmentSchema.index({ student: 1, course: 1 }, { unique: true });

module.exports = mongoose.model('Enrollment', enrollmentSchema); const mongoose = require('mongoose');

const progressSchema = new mongoose.Schema(
  {
    student: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Course',
      required: true,
    },
    completedContents: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Content',
      },
    ],
    progressPercentage: {
      type: Number,
      default: 0,
      min: 0,
      max: 100,
    },
    certificateSent: {
      type: Boolean,
      default: false,
    },
    certificateSentAt: {
      type: Date,
      default: null,
    },
    lastAccessedAt: {
      type: Date,
      default: Date.now,
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: true }
);

// Prevent duplicate progress records
progressSchema.index({ student: 1, course: 1 }, { unique: true });

module.exports = mongoose.model('Progress', progressSchema); const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema(
  {
    fullName: {
      type: String,
      required: [true, 'Please provide a full name'],
      trim: true,
    },
    email: {
      type: String,
      required: [true, 'Please provide an email'],
      unique: true,
      lowercase: true,
      match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please provide a valid email'],
    },
    phone: {
      type: String,
      required: [true, 'Please provide a phone number'],
    },
    password: {
      type: String,
      required: [true, 'Please provide a password'],
      minlength: 6,
      select: false,
    },
    role: {
      type: String,
      enum: ['student', 'admin'],
      default: 'student',
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    profileImage: {
      type: String,
      default: null,
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: true }
);

// Hash password before saving
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Method to match password
userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema); const express = require('express');
const {
  getDashboard,
  getAllUsers,
  toggleUserStatus,
  getUserEnrollments,
  getCourseAnalytics,
} = require('../controllers/admin.controller');
const { protect } = require('../middleware/auth.middleware');
const { authorize } = require('../middleware/admin.middleware');

const router = express.Router();

router.use(protect, authorize('admin'));

router.get('/dashboard', getDashboard);
router.get('/users', getAllUsers);
router.put('/users/:userId/toggle-status', toggleUserStatus);
router.get('/users/:userId/enrollments', getUserEnrollments);
router.get('/courses/:courseId/analytics', getCourseAnalytics);

module.exports = router; const express = require('express');
const {
  signup,
  login,
  getMe,
  updateProfile,
  changePassword,
} = require('../controllers/auth.controller');
const { protect } = require('../middleware/auth.middleware');

const router = express.Router();

router.post('/signup', signup);
router.post('/login', login);
router.get('/me', protect, getMe);
router.put('/update-profile', protect, updateProfile);
router.put('/change-password', protect, changePassword);

module.exports = router;const express = require('express');
const multer = require('multer');
const path = require('path');
const {
  getContentByCourse,
  getContentById,
  createContent,
  updateContent,
  deleteContent,
} = require('../controllers/content.controller');
const { protect } = require('../middleware/auth.middleware');
const { authorize } = require('../middleware/admin.middleware');

const router = express.Router();

// Multer configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    if (file.fieldname === 'videoFile') {
      cb(null, 'uploads/videos/');
    } else if (file.fieldname === 'pdfFile') {
      cb(null, 'uploads/pdfs/');
    } else if (file.fieldname === 'slideImages') {
      cb(null, 'uploads/images/');
    }
  },
  filename: (req, file, cb) => {
    const uniqueName = Date.now() + '-' + Math.round(Math.random() * 1e9);
    cb(null, uniqueName + path.extname(file.originalname));
  },
});

const upload = multer({
  storage,
  limits: { fileSize: 100 * 1024 * 1024 }, // 100MB
  fileFilter: (req, file, cb) => {
    const allowedMimes = [
      'video/mp4',
      'application/pdf',
      'image/jpeg',
      'image/png',
      'image/gif',
    ];
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type'));
    }
  },
});

router.get('/course/:courseId', getContentByCourse);
router.get('/:id', getContentById);

router.post(
  '/',
  protect,
  authorize('admin'),
  upload.fields([
    { name: 'videoFile', maxCount: 1 },
    { name: 'pdfFile', maxCount: 1 },
    { name: 'slideImages', maxCount: 10 },
  ]),
  createContent
);

router.put(
  '/:id',
  protect,
  authorize('admin'),
  upload.fields([
    { name: 'videoFile', maxCount: 1 },
    { name: 'pdfFile', maxCount: 1 },
    { name: 'slideImages', maxCount: 10 },
  ]),
  updateContent
);

router.delete('/:id', protect, authorize('admin'), deleteContent);

module.exports = router;const express = require('express');
const {
  getAllCourses,
  getCourseById,
  createCourse,
  updateCourse,
  deleteCourse,
  toggleCourseStatus,
} = require('../controllers/course.controller');
const { protect } = require('../middleware/auth.middleware');
const { authorize } = require('../middleware/admin.middleware');

const router = express.Router();

router.get('/', getAllCourses);
router.get('/:id', getCourseById);

router.post('/', protect, authorize('admin'), createCourse);
router.put('/:id', protect, authorize('admin'), updateCourse);
router.delete('/:id', protect, authorize('admin'), deleteCourse);
router.patch('/:id/toggle-status', protect, authorize('admin'), toggleCourseStatus);

module.exports = router;const express = require('express');
const {
  getMyEnrollments,
  enrollCourse,
  markAsPaid,
  getAllEnrollments,
  approveEnrollment,
  rejectEnrollment,
} = require('../controllers/enrollment.controller');
const { protect } = require('../middleware/auth.middleware');
const { authorize } = require('../middleware/admin.middleware');

const router = express.Router();

router.get('/my-enrollments', protect, getMyEnrollments);
router.post('/:courseId', protect, enrollCourse);
router.put('/:enrollmentId/mark-paid', protect, markAsPaid);

router.get('/', protect, authorize('admin'), getAllEnrollments);
router.put('/:enrollmentId/approve', protect, authorize('admin'), approveEnrollment);
router.put('/:enrollmentId/reject', protect, authorize('admin'), rejectEnrollment);

module.exports = router; const express = require('express');
const {
  getCourseProgress,
  completeContent,
  getAllProgress,
  sendCertificate,
} = require('../controllers/progress.controller');
const { protect } = require('../middleware/auth.middleware');
const { authorize } = require('../middleware/admin.middleware');

const router = express.Router();

router.get('/:courseId', protect, getCourseProgress);
router.put('/:courseId/complete/:contentId', protect, completeContent);

router.get('/', protect, authorize('admin'), getAllProgress);
router.put('/:progressId/send-certificate', protect, authorize('admin'), sendCertificate);

module.exports = router;const express = require('express');
const cors = require('cors');
const path = require('path');

const authRoutes = require('./routes/auth.routes');
const courseRoutes = require('./routes/course.routes');
const enrollmentRoutes = require('./routes/enrollment.routes');
const contentRoutes = require('./routes/content.routes');
const progressRoutes = require('./routes/progress.routes');
const adminRoutes = require('./routes/admin.routes');

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Static files
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/courses', courseRoutes);
app.use('/api/enrollments', enrollmentRoutes);
app.use('/api/content', contentRoutes);
app.use('/api/progress', progressRoutes);
app.use('/api/admin', adminRoutes);

// Health check
app.get('/api/health', (req, res) => {
  res.status(200).json({ success: true, message: 'Server is running' });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: 'Route not found',
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    success: false,
    message: err.message || 'Internal server error',
  });
});

module.exports = app;require('dotenv').config();
const app = require('./app');
const connectDB = require('./config/db');

const PORT = process.env.PORT || 5000;

// Connect to database
connectDB();

const server = app.listen(PORT, () => {
  console.log(`✓ Server running on http://localhost:${PORT}`);
  console.log(`✓ API ready at http://localhost:${PORT}/api`);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (err) => {
  console.error('✗ Unhandled Rejection:', err.message);
  server.close(() => process.exit(1));
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('✗ Uncaught Exception:', err.message);
  process.exit(1);
});# Server Config
PORT=5000
NODE_ENV=development

# Database
MONGODB_URI=mongodb+srv://valyntix:Valyntix2026@cluster0.arggszw.mongodb.net/lms-db

# JWT Security
JWT_SECRET=8f3c9e7b1a4d6f2c9b0e5a7d4c8f1e6b9a2d7c5e0f4b8a1c6d9e2a7b5
JWT_EXPIRE=7d

# Email Config (Optional)
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=ranjitthskuri@gmail.com
EMAIL_PASS=thskuri@@@@@233344411

# File Upload
MAX_FILE_SIZE=104857600
UPLOAD_PATH=uploads

# API Base URL
API_URL=http://localhost:5000  